<!DOCTYPE html>
<html lang="en">
<head>
<title>googlenet in keras</title>
<meta charset="utf-8">
<meta name="format-detection" content="telephone=no">
<link rel="icon" href="../images/favicon.ico">
<link rel="shortcut icon" href="../images/favicon.ico">
<link rel="stylesheet" href="../css/stuck.css">
<link rel="stylesheet" href="../css/style.css">
<link rel="stylesheet" href="../css/ihover.css">
<script src="../js/jquery.js"></script>
<script src="../js/jquery-migrate-1.1.1.js"></script>
<script src="../js/script.js"></script>
<script src="../js/superfish.js"></script>
<script src="../js/jquery.equalheights.js"></script>
<script src="../js/jquery.mobilemenu.js"></script>
<script src="../js/jquery.easing.1.3.js"></script>
<script src="../js/tmStickUp.js"></script>
<script src="../js/jquery.ui.totop.js"></script>
<script>
 $(document).ready(function(){
  $().UItoTop({ easingType: 'easeOutQuart' });
  $('#stuck_container').tmStickUp({});
  });
</script>
<!--[if lt IE 9]>
 <div style=' clear: both; text-align:center; position: relative;'>
   <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
     <img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0000_us.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." />
   </a>
</div>
<script src="js/html5shiv.js"></script>
<link rel="stylesheet" media="screen" href="css/ie.css">
<![endif]-->
<!--[if lt IE 10]>
<link rel="stylesheet" media="screen" href="css/ie1.css">
<![endif]-->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});
    </script>
<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</head>
<body class="page1" id="top">
<!--==============================
              header
=================================-->
<header>
<!--==============================
            Stuck menu
=================================-->
  <section id="stuck_container">
    <div class="container">
      <div class="row">

          <div class="navigation ">
            <nav>
              <ul class="sf-menu">
               <li><a href="../index.html">about</a></li>
               <li><a href="../research.html">research</a></li>
               <li class="current"><a href="../blog.html">blog</a></li>
               <li><a href="../teaching.html">teaching</a></li>
             </ul>
            </nav>

          <div class="clear"></div>
          </div>
      </div>
    </div>
  </section>
</header>
<!--=====================
          Content
======================-->
<section class="content"><div class="ic"></div>
    <div class="container">
        <div class="row">
            <div class="grid_8 preffix_2">
                <div class="ta__center">
                    <h3>googlenet in keras</h3>
                    <div class="st2">
                        <p>
                        In this new era of deep learning, a number of software libraries have cropped up, each promising users speed, ease of use, and compatibility with state-of-the-art models and techniques. The go-to library in the Caltech vision lab has been <a href="http://caffe.berkeleyvision.org/">Caffe</a>, an open-source library developed by <a href="http://daggerfs.com/">Yangquing Jia</a> and maintained by the <a href="http://bvlc.eecs.berkeley.edu/">Berkeley Vision and Learning Center (BVLC)</a>. It has been the gold standard in terms of speed and offering the latest pre-trained models (AlexNet, GoogLeNet, etc.). However, for trying anything other than what's already been done, Caffe can be rigid and difficult to adapt. Diving into the C++ code to implement a new layer can be a daunting task, and don't get me started on those .prototxt files! For research, I need a deep learning library that I can easily adapt to whatever experiment I'm working on, so I went searching for greener pastures and found <a href="http://keras.io/">Keras</a>, a python library developed by <a href="https://github.com/fchollet">Fran√ßois Chollet</a> that runs on top of <a href="http://deeplearning.net/software/theano/">Theano</a> and <a href="https://www.tensorflow.org/">Tensorflow</a>. Installing Keras and either of these backend libraries is fairly easy (just pip install), and Keras itself achieves an excellent balance of simplicity and adaptability.
                        </p>
                        
                        <p>
                        However, Keras doesn't contain the degree of pre-trained models that come complete with Caffe. There are a number of github repositories by devoted Keras followers hosting implementations of AlexNet, VGG, GoogLeNet, etc., but from what I could tell, these models didn't exactly correspond to the models I had worked with in Caffe. As I often work with GoogLeNet (which is also referred to as Inception V1), I took it upon myself to transfer the weights from Caffe into an exact replica in Keras. The following is a walkthrough of my method.
                        </p>
                        
                        <p>
                        Before we begin, if you're not interested in getting into the details of how to implement GoogLeNet in Keras yourself, feel free to just download the model. Keras models are defined by two files: a json file containing the model architecture and an hdf5 file containing the model's weights. You can use the link below to download a zip folder containing the architecture and weight files for GoogLeNet.
                        </p>
                        
                        <center><a href="googlenet.zip">Click Here to Download GoogLeNet</a></center>
                        
                        <p></p>
                        
                        <p>
                        To load the model, run the following:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/80007d609b6877822fddc1ef1cd2b71c.js"></script>
                        
                        <p>
                        I've also created a <a href="https://gist.github.com/joelouismarino/a2ede9ab3928f999575423b9887abd14">GitHub Gist</a> that contains a script with the entire model definition.
                        </p>
                        
                        <p>
                        I've laid this blog post out in two sections, constructing the network architecture and transferring the weights, however, these two phases went hand in hand. Along the way, I used the weights to generate activations to verify the network architecture.
                        </p>
                        
                        <center><b>Constructing the Network Architecture</b></center>
                        
                        <div class="box alt">
                            <div class="row 50% uniform">
                                <div class="12u$"><span class="image fit"><img src="../images/blog_images/blog_googlenet_keras/googlenet_diagram.png" alt="" /></span></div>
                            </div>
                        </div>
                        
                        <p>
                        
                        The behemoth that sits above is GoogLeNet. As part of an ensemble of other similar models trained by the researchers at Google, GoogLeNet achieved a top-5 error rate of 6.67% on the <a href="http://image-net.org/challenges/LSVRC/2014/results#clsloc">2014 ImageNet classification challenge</a>. What that means is this: if you have an image of an object that is contained in the 1,000 object classes of the ImageNet dataset (all sorts of animals, household objects, vehicles, etc.), 93.33% of the time the correct object class will be contained in the GoogLeNet ensemble's top five predictions. Considering that ImageNet consists of many fine-grained object categories and that some images contain multiple object categories, this is an incredible feat, nearly on par with human performance. While at first glance the model may appear incredibly complex, upon closer inspection, the overall structure of the model can be broken down into a few basic sections: the stem, the inception modules, the auxiliary classifiers, and finally the output classifier.
                        
                        
                        </p>
                        
                        <div class="box alt">
                            <div class="row 50% uniform">
                                <div class="12u$"><span class="image fit"><img src="../images/blog_images/blog_googlenet_keras/googlenet_components.png" alt="" /></span></div>
                            </div>
                        </div>
                        
                        <p>
                        
                        GoogLeNet starts with a sequential chain of convolution, pooling, and local response normalization operations, in a similar fashion to previous convolutional neural network models, such as AlexNet. Later papers on the inception architectures refer to this initial segment as the 'stem'. Shown below, the stem stands in contrast to the rest of the GoogLeNet architecture, which is primarily made up of what are referred to as 'inception' modules. The authors cite technical issues for including the stem rather than training a network made up entirely of inception modules. It will be interesting to see whether this stem section remains a part of future networks.
                        
                        </p>
                        
                        
                        <div class="box alt">
                            <center>
                                <div class="row uniform">
                                    <div class="6u$"><span class="image fit"><img src="../images/blog_images/blog_googlenet_keras/googlenet_stem.png" alt="" /></span></div>
                                </div>
                            </center>
                        </div>
                        
                        <p>
                        The basic building block of GoogLeNet, the inception module, is a set of convolutions and poolings at different scales, each done in parallel, then concatenated together. Along the way, $ 1 \times 1$ convolutions are used to reduce the dimensionality of inputs to convolutions with larger filter sizes. This approach results in a high performing model with drastically fewer parameters. GoogLeNet, in fact, has a factor of 12 times fewer parameters than AlexNet. Why the name inception, you ask? Because the module represents a <em>network within a network</em>. If you don't get the reference, go watch Christopher Nolan's <a href="http://www.imdb.com/title/tt1375666/">Inception</a>...computer scientists are hilarious.
                        </p>
                        
                        <div class="box alt">
                            <center>
                                <div class="row uniform">
                                    <div class="6u$"><span class="image fit"><img src="../images/blog_images/blog_googlenet_keras/inception_module.png" alt="" /></span></div>
                                </div>
                            </center>
                        </div>
                        
                        <p>
                        
                        The above diagram shows an inception module. GoogLeNet contains nine of these modules, sequentially stacked, with two max pooling layers along the way to reduce the spatial dimensions. Due to the depth of this architecture, the authors added two auxiliary classifiers branching from the main network structure. The purpose of these classifiers is to amplify the gradient signal back through the network, attempting to improve the earlier representations of the data. However, with the introduction of batch normalization, these classifiers have been ignored in recent models.
                        </p>
                        
                        <div class="box alt">
                            <center>
                                <div class="row uniform">
                                    <div class="12u$"><span class="image fit"><img src="../images/blog_images/blog_googlenet_keras/googlenet_auxiliary.png" alt="" /></span></div>
                                </div>
                            </center>
                        </div>
                        
                        <p>
                        
                        Finally, we get to the output classifier, which performs an average pooling operation followed by a softmax activation on a fully connected layer.
                        
                        </p>
                        
                        <div class="box alt">
                            <center>
                                <div class="rowuniform">
                                    <center><div class="12u$"><span class="image fit"><img src="../images/blog_images/blog_googlenet_keras/googlenet_output.png" alt="" /></span></div></center>
                                </div>
                            </center>
                        </div>
                        
                        <p>
                        
                        In total, the network uses the standard operations: convolution, pooling, normalization, and fully-connected layers. Unbeknownst to me, each of these operations are performed differently across different software libraries, so each operation required some hacking to convert from Caffe and Keras.
                        
                        </p>
                        
                        <p>
                        
                        Let's start by looking at the input. Opening GoogLeNet's deploy.prototxt file from Caffe, we first see
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/7a17eb943ff36085cf14a9abf0fe0195.js"></script>
                        
                        <p>
                        
                        What we have is a network named GoogLeNet that takes a 4-D input blob "data" with input dimensions (10, 3, 224, 224), i.e. batches of 10 images, each with 3 channels (note: in BGR order!), of size 224 $\times$ 224. In Keras, working with the <a href="http://keras.io/getting-started/functional-api-guide/">Functional API</a>, this is equivalently written as
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/01ca4a5d3ddaf60df70043917159f1c1.js"></script>
                        
                        <p>
                        The batch size is ommitted for the time being, as it gets set once we train or test with the model. Moving on, let's look at the first convolutional layer in Caffe:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/7e4df6294ec76046972a1e9a6366230c.js"></script>
                        
                        <p>
                        
                        What we see is a convolutional layer named <code>"conv1/7x7_s2"</code> that takes input from <code>"data"</code>, applies a set of 64 7 $\times$ 7 convolutional filters with a stride of 2 and a padding of 3, then passes the activations through the ReLU layer <code>"conv1/relu_7x7"</code>. In Keras, we can implement this using a <code>Convolution2D</code> layer as follows:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/1614950a339330bcb2c24f17d56da364.js"></script>
                        
                        <p>
                        
                        We use the <code>subsample</code> and <code>border_mode</code> keyword arguments to handle the stride and padding respectively. By setting <code>border_mode='same'</code>, we tell Keras that we want to pad the input with zeros such that the spatial output size of the layer (if we were to neglect the stride) would be the same as the input size. For a filter size of 7 $\times$ 7, this would correspond to a padding of 3, as in Caffe. Next, we move on to a pooling layer:
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/328dbfd8e69b37a32fe3db077b9d1dc7.js"></script>
                        
                        <p>
                        This max-pooling layer takes input from <code>"conv1/7x7_s2"</code> and uses a 3 $\times$ 3 window with stride 2 to subsample the maximum activations from the convolution. Since the layer's prototxt definition does not specify any padding, this is considered to be a 'valid' operation, i.e. only take maxima at locations where the window completely overlaps the input. In Keras, we would implement this using a <code>MaxPooling2d</code> layer:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/23e6066aad4492701af172fe1a35d286.js"></script>
                        
                        <p>
                        However, <b>this operation is not consistent from Caffe to Keras.</b> After some frustration, I found that Caffe actually does pad the end of both spatial dimensions. In this way, with indexing ranging from (0, 0) to (111, 111), the first pooling location is centered at (1, 1), but the last pooling location is centered at (111, 111). Valid at the beginning, same at the end. My solution: zero-pad the result from the convolutional layer, then use a custom layer to remove the zeros from the beginning of both dimensions (the first row and column). Thus,
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/cd0248a8cce6dd23a9c9ef287a2974f0.js"></script>
                        
                        <p>
                        where <code>PoolHelper</code> is a custom layer, implemented as
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/330d77b54c4e98c0bd2247a5554a362f.js"></script>
                        
                        <p>
                        Sure enough, this does the trick. Now on to normalization. In Caffe, the local response normalization layers are defined as
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/f5d025ea0a6b315526d5fb0297e3f3a8.js"></script>
                        
                        <p>
                        
                        What do the hyperparameters <code>local_size</code>, <code>alpha</code>, and <code>beta</code> mean? In Caffe, the local response normalization is performed for each example by normalizing along the feature (channel) dimension. This normalization is performed only over a small window, the <em>local size</em>, over features at every spatial location. The parameters $\alpha$ and $\beta$ come in through the normalization equation:
                        
                        \begin{equation}
                        LRN(x_{f,r,c}) = \left( k + \frac{\alpha}{n} \sum_{i=f-\frac{n}{2}}^{f+\frac{n}{2}} x_{i,r,c}^2 \right)^\beta.
                        \end{equation}
                        
                        Let's deconstruct this equation. The local response normalization of the input $x_{f,r,c}$ at a particular feature $f$ at row $r$ and column $c$ is given by an offset $k$ plus a scaling coefficient $\alpha$ times the average squared input over the centered window of size $n$ (the local size), all taken to the power of $\beta$. Again, note that the window extends only over the feature dimension, meaning that each spatial location is normalized separately. In Caffe, $k$ is set to 1.
                        
                        </p>
                        
                        <p>
                        
                        In the latest version of Keras, the only form of normalization is the <code>BatchNormalization</code> layer. And while this layer is useful and versatile, especially with the widespread adoption and nice theoretical motivations of batch normalization, it does not perform local response normalization in the same way as Caffe. <a href="https://github.com/fchollet/keras/blob/97174dd298cf4b5be459e79b0181a124650d9148/keras/layers/normalization.py#L66">Previous versions</a> of Keras included a <code>LRN2D</code> layer, which was adapted from pylearn2, however I had to make modifications to this code to obtain the identical operation performed by Caffe. The layer definition is below:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/b78257a716df15fb1886442927cc6d72.js"></script>
                        
                        <p>
                        I have added comments to explain the steps along the way. Now we can add the LRN layer to our network:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/ce3e66a9aee6e6f5dcbb2ec0ef48d2c2.js"></script>
                        
                        <p>
                        Now you might be thinking to yourself, "We're only three layers in! This is going to take forever!" Not to fear, after accounting for the differences in pooling and normalization between Caffe and Keras, the rest of the network is a straightforward conversion. The rest of the stem can be completed similarly to the first three layers. I'll spare you the prototxt version, but in Keras, the first inception module looks like this:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/6ff9a26ce925891b539cb82faf00a1f7.js"></script>
                        
                        <p>
                        We see 1 $\times$ 1, 3 $\times$ 3, and 5 $\times$ 5 convolutions with varying numbers of filters in addition to a pooling layer. At the end, the outputs of these different pathways are concatenated using Keras' <code>merge</code> layer. The next inception module will then take its input from this concatenated layer. The rest of the inception layers are exactly identical, but with different numbers of filters.
                        
                        </p>
                        
                        <p>
                        Finally, we get to the classifiers. Since the auxiliary classifiers are not included in Caffe's deploy model, I will focus on the final classifier (the auxiliary classifiers are nearly identical). At the beginning of each classifier branch is an <em>average</em> pooling layer. In Caffe, this is written as
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/0507635983484a59889f1c6a0663d47e.js"></script>
                        
                        <p>
                        In Keras, we can use the <code>AveragePooling2D</code> layer to implement this:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/d7abb298f2be06a900a4f4b7a29369e1.js"></script>
                        
                        <p>
                        We then come to a dropout layer.
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/51d9553e20abe87ffbd788cd0074e900.js"></script>
                        
                        <p>
                        This is simply implemented using Keras' <code>Dropout</code> layer. However, before this point, I flatten the input to get rid of the spatial dimensions, which by this point, are both of size 1.
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/c1496bb0a299a19090a516c13e797c62.js"></script>
                        
                        <p>
                        ...and finally the output softmax layer.
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/ab8244fd192b9d12cff94f348bf3ebd6.js"></script>
                        
                        <p>
                        This is implemented in Keras using a <code>Dense</code> layer (with default linear activation) followed by a softmax <code>Activation</code> layer.
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/f18aeed55c35903b0a622b8190d0c037.js"></script>
                        
                        <p>
                        
                        Finally, in Keras, we need to turn the set of layers into a model by specifying the input and output.
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/f949b364386d1e67112865e68155fbda.js"></script>
                        
                        <p>
                        
                        And that's all there is to it! At this point, to train the model, we would simply need to compile the it (likely using <code>'categorical_crossentropy'</code> for the loss function) and start feeding in batches of training examples. Don't forget: in order to train, you will also want to add the <code>W_regularizer</code> argument to each of the convolution and fully-connected layers. Caffe specifies the regularization hyperparameter as being 0.0002.
                        </p>
                        
                        <p>
                        However, the main point of reconstructing this network in Keras was to take advantage of the pre-trained weights from Caffe. In the next section, I'll walk through the process of transferring these weights over.
                        </p>
                        
                        <center><b>Transferring the Weights</b></center>
                        
                        <p>
                        
                        GoogLeNet's weights are contained in a caffemodel file and can be accessed by loading them in Caffe. With the deploy.prototxt file, this is done as follows:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/a4068d94b5f886f381b24166975d1307.js"></script>
                        
                        <p>
                        The model's weights and biases are accessed through <code>net.params</code>, whereas each layer's activations are accessed through <code>net.blobs</code>. Therefore, to copy over the weights, we can run the following script:
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/d22a1677d7a76ec4ab074d44f8ceb921.js"></script>
                        
                        <p>
                        We run through all of the layers, copying over the weights and biases from Caffe, then set those parameters in the corresponding layer in Keras. Unfortunately, if we run this script, we will encounter two errors, one of which will be obvious, and the other one not. The first error occurs due to the fact that the weights for fully-connected layers are transposed between Caffe and Keras. This is simply a convention between libraries. We can remedy this error by adding the following:
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/1c4592a512e81b080c24aabeac2b278d.js"></script>
                        
                        <p>
                        The other error is more difficult to catch. Caffe and Keras do not implement convolutional layers in the same manner. Keras (really Theano) performs convolution, whereas Caffe performs correlation. For more information on how these differ, see <a href="http://www.cs.umd.edu/~djacobs/CMSC426/Convolution.pdf">this explanation</a>. In real terms, this simply means that we need to rotate each of the filters by 180$^{\circ}$:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/4d62afde11e2a0f2abe8780663c5495c.js"></script>
                        
                        <p>
                        Upon adding these two catches into our copying script, we can now copy the weights over. And there you have it, GoogLeNet in Keras!
                        
                        </p>
                        
                        <center><b>Testing the Model</b></center>
                        
                        <p>
                        Just to make sure everything went off without a hitch, let's try running a sample image through both networks to verify that the activations are consistent. While copying over the weights, this was how I debugged the Keras model. Let's use the sample image used by Caffe, that adorable tabby cat kitten:
                        </p>
                        
                        <div class="box alt">
                            <center>
                                <div class="rowuniform">
                                    <div class="6u$"><span class="image fit"><img src="../images/blog_images/blog_googlenet_keras/kitten.png" alt="" /></span></div>
                                </div>
                            </center>
                        </div>
                        
                        <p>
                        First we'll preprocess the image by subtracting the channels means, changing the channel ordering, switching the spatial and channel dimensions, cropping the image, and adding an extra dimension for the batch.
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/aa565be7cc5a450b117fefee8d9440f0.js"></script>
                        
                        <p>
                        
                        Now we can run the image through Caffe. We reshape the data layer to contain a single example and pass our image into this layer. We then call the network's <code>forward</code> function to propagate the activations through the layers.
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/3bd690112f333df3c9e49d15939298bc.js"></script>
                        
                        <p>
                        To get the activations in Keras, we will define a function that takes in a model, a layer, and an input and returns that layer's activations.
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/b3ab571006d4b719a4eccde1b9bc0cb6.js"></script>
                        
                        <p>
                        We can now compare activations between the two networks at any layer. If we have a layer called <code>layer_name</code>, we can get the activations as:
                        
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/47d37f931f894e9202375f6ee59d5d80.js"></script>
                        
                        <p>
                        Rather than show the activations for each and every layer, I will show the final output of each model by setting <code>layer_name='prob'</code>. In Caffe, the image of the kitten results in
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/cd0fde1650ec0e9169771cbbd2bfd27e.js"></script>
                        
                        <center>
                        <p>
                        n02123394, Persian cat, 0.79362965
                        </p>
                        <p>
                        n02127052, lynx, catamount, 0.081304103
                        </p>
                        <p>
                        n02123159, tiger cat, 0.074268937
                        </p>
                        <p>
                        n02123045, tabby, tabby cat, 0.029699767
                        </p>
                        <p>
                        n04589890, window screen, 0.0024248438
                        </p>
                        </center>
                        
                        <p>
                        While in Keras, we get the following:
                        </p>
                        
                        <script src="https://gist.github.com/joelouismarino/4f188564c870e080de2531c8641a797c.js"></script>
                        
                        <center>
                            <p>
                            n02123394, Persian cat, 0.79363048
                            </p>
                            <p>
                            n02127052, lynx, catamount, 0.081303641
                            </p>
                            <p>
                            n02123159, tiger cat, 0.074268863
                            </p>
                            <p>
                            n02123045, tabby, tabby cat, 0.029699543
                            </p>
                            <p>
                            n04589890, window screen, 0.0024248327
                            </p>
                        </center>
                        
                        <p>
                        Immediately, we see that the network struggled with this image. Honestly...Persian cat?
                        
                        </p>
                        
                        <div class="box alt">
                            <center>
                                <div class="rowuniform">
                                    <div class="6u$"><span class="image fit"><img src="../images/blog_images/blog_googlenet_keras/persian-cat.jpg" alt="" /></span></div>
                                </div>
                            </center>
                        </div>
                        
                        <p>
                        I'm no cat expert, but the original image looks to be a tabby. I guess object classification (and computer vision more generally) hasn't been solved. Comparing the probabilities between the two networks, we see that they match up to about four decimal places. I'm not sure specifically where this comes from, but it could be an artifact of the number of bits used to store activations throughout the networks. For all intents and purposes, the networks produce identical outputs. Now get out there and have some fun with GoogLeNet!
                        
                        </p>
                        
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    
</section>

</body>
</html>
